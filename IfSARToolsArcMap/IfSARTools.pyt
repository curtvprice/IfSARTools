# -*- coding: utf-8 -*-import sysimport osimport arcpyfrom arcpy.sa import Rasterclass Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "IfSAR Tools for ArcMap"        self.alias = "ista"        # List of tool classes associated with this toolbox        self.tools = [ExportROIPACdem, ROIPACImport, DMtoBox, RasterRanger, SNAPImport]class ExportROIPACdem(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Export ROIPAC DEM"        self.description = "Convert ArcGIS raster to ROIPAC .dem format"        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName="Input Elevation Raster",            name="in_raster",            datatype="GPRasterLayer",            parameterType="Required",            direction="Input")        param1 = arcpy.Parameter(            displayName="Output name",            name="output_name",            datatype="GPString",            parameterType="Required",            direction="Input")        param2 = arcpy.Parameter(            displayName="Output folder",            name="output_folder",            datatype="DEFolder",            parameterType="Required",            direction="Input")        param3 = arcpy.Parameter(            displayName="Unix path",            name="unix_path",            datatype="GPString",            parameterType="Required",            direction="Input")        param4 = arcpy.Parameter(            displayName="Aggregation factor",            name="agg_factor",            datatype="GPLong",            parameterType="Optional",            direction="Input")        return [param0, param1, param2, param3, param4]    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        if parameters[0].value:            ras = parameters[0].valueAsText            if not parameters[1].value:                parameters[1].value = os.path.basename(os.path.splitext(ras)[0])            else:                nm = parameters[1].valueAsText                nm1 = arcpy.ValidateTableName(nm)                if nm != nm1:                    parameters[1].value = nm1            if not parameters[2].value:                rasdir = os.path.dirname(arcpy.Describe(ras).catalogPath)                if rasdir.find(".gdb") != -1:                    rasdir = os.path.dirname(rasdir)                parameters[2].value = rasdir            if not parameters[3].value:                parameters[3].value = "/home/{}".format(os.environ["USERNAME"])        if not parameters[4].value:            parameters[4].value = 1        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        if parameters[4].value < 1 or parameters[4].value > 4:            parameters[4].setErrorMessage("Value must be between 1 and 4")        return    def execute(self, parameters, messages):        """The source code of the tool."""        import os        import shutil        import io        import math        inraster = parameters[0].valueAsText        outname = parameters[1].valueAsText        outfolder = parameters[2].valueAsText        filedir = parameters[3].valueAsText        aggfactor = parameters[4].value        # if aggregating use Aggregate tool        if aggfactor > 1:            messages.addMessage("Aggregating cells by a factor of {}...".format(aggfactor))            tmp_agg = arcpy.CreateScratchName("",".tif", "RasterDataset", arcpy.env.scratchFolder)            tmp = arcpy.sa.Aggregate(Raster(inraster), aggfactor, "MEAN")            tmp.save(tmp_agg)        else:            tmp_agg = ""            tmp = Raster(inraster)        # copy raster to binary unsigned integer        tmp_raster = arcpy.CreateScratchName("",".bil", "RasterDataset", arcpy.env.scratchFolder)        arcpy.management.CopyRaster(tmp, tmp_raster,            nodata_value=0, pixel_type="16_BIT_UNSIGNED")        out_dem = os.path.join(outfolder, outname + ".dem")        shutil.copyfile(tmp_raster, out_dem)        dem = arcpy.sa.Raster(tmp_raster)        cell = dem.meanCellHeight        cellmeters =  math.pi * 6371000 * cell / 180        messages.addMessage("Output raster cell size: {:.6f} degrees ({:.1f} arc-sec, about {:.1f} m)".format(            cell, cell * 3600, cellmeters))        # create resource file        # note upper-left is recalculated as center of cell (to match ArcGIS .hdr file)        # roi_pac doc has a question mark whether center of cell is correct.        fmt = """FILE_DIR     {}WIDTH        {}FILE_LENGTH  {}XMIN         0XMAX         {}YMIN         0YMAX         {}X_FIRST      {:.6f}Y_FIRST      {:.6f}X_STEP       {:.6f}Y_STEP       {:.6f}X_UNIT       degresY_UNIT       degresZ_OFFSET     -24Z_SCALE      1PROJECTION   LATLON""".format(filedir, dem.width, dem.height,            dem.width - 1, dem.height - 1,            dem.extent.XMin + (cell * 0.5), dem.extent.YMax - (cell * 0.5),            cell, cell * -1)        rscfile = os.path.join(outfolder, outname + ".dem.rsc")        # io.open() used to ensure unix new lines for ROIPAC        with io.open(rscfile, 'w', newline='') as f:            f.write(fmt[1:].decode('utf-8'))        f.close()        if tmp_agg:            arcpy.Delete_management(tmp_agg)        out_tif = os.path.join(outfolder, outname + "_tif.tif")        arcpy.management.CopyRaster(tmp_raster, out_tif)        arcpy.Delete_management(tmp_raster)        messages.addMessage("Created:\n{}\n{}\n{}".format(            out_dem, rscfile, out_tif))        returnclass ROIPACImport(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "ROIPAC Import"        self.description = "Import unwrapped ROIPAC interferogram phase image and convert to cm"        self.canRunInBackground = True    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName="Input Raster",            name="in_raster",            datatype="GPRasterLayer",            parameterType="Required",            direction="Input")                    param1 = arcpy.Parameter(            displayName="Output raster",            name="out_raster",            datatype="DERasterDataset",            parameterType="Required",            direction="Output")                    param2 = arcpy.Parameter(            displayName="Platform",            name="platform",            datatype="GPString",            parameterType="Optional",            direction="Input")        param2.filter.list = ["ALOS", "ENVISAT"]                param3 = arcpy.Parameter(            displayName="rscfile",            name="rscfile",            datatype="DEFile",            parameterType="Optional",            direction="Input")        param3.filter.list = ["rsc"]        return [param0, param1, param2, param3]    def isLicensed(self):        """Allow the tool to execute, only if the ArcGIS Spatial Analyst extension        is available."""        try:            if arcpy.CheckExtension("spatial") != "Available":                raise Exception        except Exception:            return False  # tool cannot be executed        return True  # tool can be executed    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        if parameters[0].value:            # If there is a Band_2 assume it is unwrapped phase in Band 2            # (this is how it comes from ROIPAC)            ras = arcpy.Describe(parameters[0].valueAsText).catalogPath            parameters[0].setWarningMessage(ras)            if arcpy.Exists(ras + "/Band_2"):                parameters[0].setWarningMessage("Assuming Band 2 is phase image in radians (ROIPAC convention)")            # set default output raster name            if not parameters[0].hasBeenValidated:                ras = arcpy.Describe(parameters[0].value).catalogPath                rasname = os.path.basename(ras)                oras = arcpy.ValidateTableName(os.path.splitext(rasname)[0])                try:                    if arcpy.env.workspace[-4:] != ".gdb":                        oras = oras + ".tif"                except:                    pass                parameters[1].value = os.path.join(arcpy.env.workspace, oras)                            if arcpy.Describe(ras).SpatialReference.name == "Unknown":                parameters[3].enabled = True            else:                parameters[3].enabled = False                parameters[3].value = None    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        if not parameters[2].value:            parameters[2].value = "ALOS"        return    def execute(self, parameters, messages):        """The source code of the tool."""        import os        import math        from arcpy import env        from arcpy.sa import Raster                def rscwarp(in_raster, out_raster, rscfile):            with open(rscfile) as rfile:                d = {}                for line in rfile:                    (key, val) = line.split()                    d[key] = val            xfirst, yfirst = [                float(d[k]) for k in ("X_FIRST", "Y_FIRST")]            (xmin, xmax, ymin, ymax) = [                float(d[k]) for k in ("XMIN", "XMAX", "YMIN", "YMAX")]            xstep, ystep  = [                float(d[k]) for k in ("X_STEP", "Y_STEP")]            xyin = "{} {};{} {};{} {}".format(                xmin, ymax, xmin, ymin, xmax, ymax)            xyout = "{} {};{} {};{} {}".format(                xfirst, yfirst, xfirst, yfirst + (ystep * ymax),                    xfirst + (xstep * xmax), yfirst)                                messages.addMessage("XMIN, XMAX, YMIN, YMAX: {}".format(                (xmin, xmax, ymin, ymax)))            messages.addMessage("Extent: {}".format(                (xfirst, yfirst + (ystep * ymax), xfirst + (xstep * xmax), yfirst)))                                arcpy.management.Warp(in_raster, xyin, xyout,                 out_raster, "POLYORDER1", "BILINEAR")            arcpy.management.DefineProjection(out_raster,                arcpy.SpatialReference(4326))                        input_raster = parameters[0].valueAsText        # If there is a Band_2 assume it is unwrapped phase in Band 2        # (this is how it comes from ROIPAC)        ras = arcpy.Describe(input_raster).catalogPath        b2 = os.path.join(ras, "Band_2")        if arcpy.Exists(b2):            ras = b2            messages.addMessage("Using {}".format(ras))        output_raster = parameters[1].valueAsText        platform = parameters[2].valueAsText        platform = str(platform).upper()        if platform == "ALOS":            lam = 23.62        else:            lam = 5.66        messages.addMessage("")        messages.addMessage("Wavelength for {}: {} cm".format(platform, lam))        messages.addMessage("Converting radians to cm: (-x / 2*pi) * ({} / 2.0)) ...".format(lam))        outras = ((-1 * arcpy.sa.Raster(ras)) / (2 * math.pi)) * (lam / 2.0)                # if rsc file is specified, georeference raster        rscfile = parameters[3].valueAsText        if rscfile:            messages.addMessage("Georeferencing using {}...".format(rscfile))            tmp = arcpy.CreateScratchName("x2", ".tif", "RasterDataset", arcpy.env.scratchFolder)            outras.save(tmp)            rscwarp(tmp, output_raster, rscfile)            arcpy.Delete_management(tmp)        else:            outras.save(output_raster)        returnclass DMtoBox(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Corners to Box"        self.description = "Convert four latitude longitude coordinates to a polygon"        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName="LatLong1",            name="latlong1",            datatype="GPString",            parameterType="Required",            direction="Input")        param1 = arcpy.Parameter(            displayName="LatLong2",            name="latlong2",            datatype="GPString",            parameterType="Required",            direction="Input")        param2 = arcpy.Parameter(            displayName="LatLong3",            name="latlong3",            datatype="GPString",            parameterType="Required",            direction="Input")        param3 = arcpy.Parameter(            displayName="LatLong4",            name="latlong4",            datatype="GPString",            parameterType="Required",            direction="Input")        param4 = arcpy.Parameter(            displayName="Output polygon",            name="out_polygon",            datatype="DEFeatureCLass",            parameterType="Required",            direction="Output")        return [param0, param1, param2, param3, param4]    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        for ip in range(4):            if parameters[ip].value:                try:                    test = [float(x) for x in parameters[ip].valueAsText.split()]                    if len(test) not in [2, 4]: raise Exception                except:                    parameters[ip].setErrorMessage("Invalid format")        return    def execute(self, parameters, messages):        """The source code of the tool."""        pts = [parameters[k].valueAsText for k in range(4)]        out_poly = parameters[4].valueAsText        pts = [[float(p) for p in p.split()] for p in pts]        # convert d m to deg if necessary        pts1 = []        for p in pts:            if len(p) == 4:                if p[0] < 0:                    p[1] = p[1] * -1                if p[2] < 0:                    p[3] = p[3] * -1                pp = [p[0] + p[1] / 60.0, p[2] + p[3] / 60.0]            else:                pp = p            pts1.append(pp)        # pts1 is in the form: [[40.0, -75.0], [40.25, -75.0], [40.35, -74.75], [40.08, -74.75]]        if arcpy.GetInstallInfo()["ProductName"] == "Desktop":            outfolder = "in_memory"        else:            outfolder = "memory"        # create empty feature class and populate it with our points        SR = arcpy.SpatialReference(4326)  #GCS WGS84        ptfc = arcpy.CreateFeatureclass_management(            outfolder, "xxtmp", "POINT", spatial_reference=SR)        with arcpy.da.InsertCursor(ptfc, "Shape") as rows:           for xy in pts1:                p = arcpy.Point(xy[1],xy[0])  # lat, long is y,x                rows.insertRow([p])        # convert to polygon        arcpy.management.MinimumBoundingGeometry(ptfc, out_poly, "CONVEX_HULL", "ALL")        arcpy.management.Delete(ptfc)        returnclass RasterRanger(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Raster Ranger"        self.description = "Calculate parameters for display of unwrapped IfSAR"        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName="Input raster",            name="input_raster",            datatype="GPRasterLayer",            parameterType="Required",            direction="Input")        param1 = arcpy.Parameter(            displayName="Cycle length (cm)",            name="cycle_length",            datatype="GPDouble",            parameterType="Optional",            direction="Input")        param2 = arcpy.Parameter(            displayName="Number of cycles",            name="cycles",            datatype="GPLong",            parameterType="Optional",            direction="Input")        param2.value = 1        param3 = arcpy.Parameter(            displayName="Range min",            name="range_min",            datatype="GPDouble",            parameterType="Optional",            direction="Input")        param4 = arcpy.Parameter(            displayName="Range max",            name="range_max",            datatype="GPDouble",            parameterType="Optional",            direction="Input")        param5 = arcpy.Parameter(            displayName="Exclude zero",            name="exclude_zero",            datatype="GPBoolean",            parameterType="Optional",            direction="Input")        param5.value = True        param6 = arcpy.Parameter(            displayName="Output layer",            name="output_layer",            datatype="GPFeatureLayer",            parameterType="Derived",            direction="Output")        return [param0, param1, param2, param3, param4, param5, param6]    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        # if raster selected, populate min and max the raster        # user can then override this        if parameters[0].value:            try:                rast = Raster(arcpy.Describe(                parameters[0].valueAsText).catalogPath)                if rast.minimum == None:                    try:                        arcpy.CalculateStatistics_management(rast)                        rast = Raster(arcpy.Describe(                            parameters[0].valueAsText).catalogPath)                    except:                        raise Exception("Could not calculate raster statistics")            except:                return        else:            for k in range(1,5):                parameters[k].value = None            return        # if user changes raster initialize values        if not parameters[0].hasBeenValidated:            parameters[1].value = rast.maximum - rast.minimum            parameters[2].value = 1            parameters[3].value = rast.minimum            parameters[4].value = rast.maximum            return        # if range parameters outside range, set from raster        rmin,rmax = parameters[3].value, parameters[4].value        if float(rmin) < rast.minimum or float(rmin) > rast.maximum:             parameters[3].value = rast.minimum        if float(rmax) < rast.minimum or float(rmin) > rast.maximum:             parameters[4].value = rast.maximum        # calculate data range to display        rdelt = rmax - rmin        # if user changes rmin rmax, initialize clen and cycles        if not (parameters[3].hasBeenValidated and parameters[4].hasBeenValidated):            parameters[1].value = rdelt            parameters[2].value = 1        # if user clears length or changes number of cycles, calc length        if parameters[1].value == None or not parameters[2].hasBeenValidated:            parameters[1].value = rdelt / float(parameters[2].value)        # if user clears # of cycles or changes length, calc # of cycles        if parameters[2].value == None or not parameters[1].hasBeenValidated:            parameters[2].value = int(rdelt / float(parameters[1].value))        # if cycles is zero, or length is too long, re-initialize        if parameters[2].value < 1 or parameters[2].value > rdelt:            parameters[1].value = rdelt            parameters[2].value = 1    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        if parameters[2].value < 1 or parameters[2].value > 10:            parameters[2].setErrorMessage("Value must between 1 and 10. To see more detail, change the data range.")        try:            rmin,rmax = float(parameters[3].value), float(parameters[4].value)            if (rmax - rmin) < float(parameters[1].value) - 0.01:                parameters[1].setErrorMessage("Cycle length longer than data range")            # check for end of range less than max (last cycle not at max range)            tmax = rmin + float(parameters[1].value) * float(parameters[2].value)            if (rmax - tmax) > 0.00001:                parameters[4].setWarningMessage(                    "Values above end of last cycle ({:.3f}) will not display.".format(tmax))        except:            pass        return    def execute(self, parameters, messages):        """The source code of the tool."""        rast = Raster(arcpy.Describe(parameters[0].valueAsText).catalogPath)        clen = float(parameters[1].value)        cycles = int(parameters[2].value)        rmin = float(parameters[3].value)        rmax = rmin + (cycles * clen)        exclude_zero = parameters[5].value        msg = "Cycle length (cm): {:.3f}   Number of cycles: {}   min: {:.3f}   max: {:.3f}".format(            clen, cycles, rmin, rmax)        messages.addMessage(msg)        if (rmin - rast.minimum) > 0.01 or (rast.maximum - rmax > 0.01):            messages.addWarningMessage((                "raster min: {:.3f}   max: {:.3f} "                "- some values will not be displayed").format(rast.minimum, rast.maximum))        excludes = math.floor(rast.minimum), rmin, rmax, math.ceil(rast.maximum)        if exclude_zero:#and (rmin < 0 and rmax > 0):            # -10 - -9.823945045469999; -0.0001 - 0.0001; 9.8389005661 - 10            ex_str = "{} - {:.3f}; -0.0001 - 0.0001; {:.3f}- {}".format(*excludes)        else:            ex_str = "{}-{:.3f}; {:.3f}-{}".format(*excludes)        # create output layer and add to map        results = "{:.1f} cm ({} cycles) {}".format(            clen, cycles, os.path.basename(rast.catalogPath))        fringe_shades = os.path.join(os.path.dirname(__file__),            "lyr", "Fringe{}.lyr".format(cycles))        outlyr = arcpy.mapping.Layer(fringe_shades)        pth = os.path.dirname(rast.catalogPath)        try:            outlyr.replaceDataSource(pth, "NONE", os.path.basename(rast.catalogPath))        except:            outlyr.replaceDataSource(pth, "FILEGDB_WORKSPACE", os.path.basename(rast.catalogPath))        outlyr.symbology.excludedValues = ex_str        outlyr.symbology.reclassify()        outlyr.name = results        mxd = arcpy.mapping.MapDocument("CURRENT")        arcpy.mapping.AddLayer(mxd.activeDataFrame, outlyr)        arcpy.RefreshActiveView()        arcpy.SetParameterAsText(6, outlyr)        returnclass SNAPImport(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "SNAP Import"        self.description = "Set cells below "        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName="Displacement raster (unwrapped, m)",            name="disp_raster",            datatype="GPRasterLayer",            parameterType="Required",            direction="Input")        param1 = arcpy.Parameter(            displayName="Output raster",            name="output_raster",            datatype="DERasterDataset",            parameterType="Required",            direction="Output")        param2 = arcpy.Parameter(            displayName="Scale factor (100 for m to cm)",            name="scale_factor",            datatype="GPDouble",            parameterType="Optional",            direction="Output")        param3 = arcpy.Parameter(            displayName="Coherence image",            name="coherence_raster",            datatype="GPRasterLayer",            parameterType="Optional",            direction="Input")        param4 = arcpy.Parameter(            displayName="Coherence threshhold",            name="coh_thresh",            datatype="GPDouble",            parameterType="Optional",            direction="Input")        return [param0, param1, param2, param3, param4]    def isLicensed(self):        """Set whether tool is licensed to execute."""        try:            if arcpy.CheckExtension("spatial") != "Available":                raise Exception        except Exception:            return False  # tool cannot be executed        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        # set default output raster name        if not parameters[0].hasBeenValidated:            ras = arcpy.Describe(parameters[0].value).catalogPath            rasname = os.path.basename(ras)            oras = arcpy.ValidateTableName(os.path.splitext(rasname)[0])            parameters[1].value = os.path.join(arcpy.env.workspace, oras)          # populate defaults threshhold only if we have a coherence raster        try:            scale_factor = float(parameters[2].value)        except:            scale_factor = 100.0        parameters[2].value = scale_factor        if parameters[3].value:            parameters[4].enabled = True            if not parameters[4].value or float(parameters[4].value) < 0.001:                parameters[4].value = 0.5        else:            parameters[4].value = None            parameters[4].enabled = False        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        if parameters[1].value:            pth = parameters[1].valueAsText.lower()            if pth.find(".gdb") > -1 and pth.find(".tif") > -1:                parameters[1].setErrorMessage("Cannot write .tif format to file geodatabase")        return    def execute(self, parameters, messages):        """The source code of the tool."""        from arcpy.sa import Float, Con, SetNull, IsNull, Expand, FocalStatistics, NbrCircle        messages.addMessage(parameters[0].value)        disp_raster = Raster(arcpy.Describe(parameters[0].value).catalogPath)        output_raster = str(parameters[1].value)        scale_factor = float(parameters[2].value)        if parameters[3].value:            coh = True            coherence_raster = Raster(arcpy.Describe(parameters[3].value).catalogPath)        else:            coh = False        try:            coh_thresh = float(parameters[4].value)        except:            coh_thresh = 0        # convert SNAP phase raster from m to cm        outras = Float(disp_raster) * scale_factor        if coh and coh_thresh > 0:            # set cells below coherence threshhold to NoData            outras1 = Con(coherence_raster > float(coh_thresh), outras)            outras = outras1        outras.save(output_raster)        return 