# -*- coding: utf-8 -*-import sysimport osimport arcpyfrom arcpy.sa import Rasterclass Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "IfSAR Tools for Pro"        self.alias = "istp"        # List of tool classes associated with this toolbox        self.tools = [ExportROIPACdem, ROIPACImport, DMtoBox, RasterRanger, ZeroOff, SNAPImport]class ExportROIPACdem(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Export ROIPAC DEM"        self.description = "Convert ArcGIS raster to ROIPAC .dem format"        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName="Input Elevation Raster",            name="in_raster",            datatype="GPRasterLayer",            parameterType="Required",            direction="Input")        param1 = arcpy.Parameter(            displayName="Output name",            name="output_name",            datatype="GPString",            parameterType="Required",            direction="Input")        param2 = arcpy.Parameter(            displayName="Output folder",            name="output_folder",            datatype="DEFolder",            parameterType="Required",            direction="Input")        param3 = arcpy.Parameter(            displayName="Unix path",            name="unix_path",            datatype="GPString",            parameterType="Required",            direction="Input")                    param4 = arcpy.Parameter(            displayName="Aggregation factor",            name="agg_factor",            datatype="GPLong",            parameterType="Optional",            direction="Input")                            return [param0, param1, param2, param3, param4]    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        if parameters[0].value:            ras = parameters[0].valueAsText            if not parameters[1].value:                parameters[1].value = os.path.basename(os.path.splitext(ras)[0])            else:                nm = parameters[1].valueAsText                nm1 = arcpy.ValidateTableName(nm)                if nm != nm1:                    parameters[1].value = nm1            if not parameters[2].value:                rasdir = os.path.dirname(arcpy.Describe(ras).catalogPath)                if rasdir.find(".gdb") != -1:                    rasdir = os.path.dirname(rasdir)                parameters[2].value = rasdir            if not parameters[3].value:                parameters[3].value = "/home/{}".format(os.environ["USERNAME"])                        if not parameters[4].value:            parameters[4].value = 1                    return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        if parameters[4].value < 1 or parameters[4].value > 4:            parameters[4].setErrorMessage("Value must be between 1 and 4")        return    def execute(self, parameters, messages):        """The source code of the tool."""        import os        import shutil        import io        import math        inraster = parameters[0].valueAsText        outname = parameters[1].valueAsText        outfolder = parameters[2].valueAsText        filedir = parameters[3].valueAsText        aggfactor = parameters[4].value               # if aggregating use Aggregate tool        if aggfactor > 1:            messages.addMessage("Aggregating cells by a factor of {}...".format(aggfactor))            tmp_agg = arcpy.CreateScratchName("",".tif", "RasterDataset", arcpy.env.scratchFolder)            tmp = arcpy.sa.Aggregate(Raster(inraster), aggfactor, "MEAN")            tmp.save(tmp_agg)        else:            tmp_agg = ""            tmp = Raster(inraster)                                  # copy raster to binary unsigned integer        tmp_raster = arcpy.CreateScratchName("",".bil",             "RasterDataset", arcpy.env.scratchFolder)        arcpy.management.CopyRaster(tmp, tmp_raster,             nodata_value=0, pixel_type="16_BIT_UNSIGNED")        out_dem = os.path.join(outfolder, outname + ".dem")        shutil.copyfile(tmp_raster, out_dem)        dem = arcpy.sa.Raster(tmp_raster)        cell = dem.meanCellHeight        cellmeters =  math.pi * 6371000 * cell / 180                messages.addMessage("Output raster cell size: {:.6f} degrees ({:.1f} arc-sec, about {:.1f} m)".format(            cell, cell * 3600, cellmeters))                    # create resource file        # note upper-left is recalculated as center of cell (to match ArcGIS .hdr file)        # roi_pac doc has a question mark whether center of cell is correct.        fmt = """FILE_DIR     {}WIDTH        {}FILE_LENGTH  {}XMIN         0XMAX         {}YMIN         0YMAX         {}X_FIRST      {:.6f}Y_FIRST      {:.6f}X_STEP       {:.6f}Y_STEP       {:.6f}X_UNIT       degresY_UNIT       degresZ_OFFSET     -24Z_SCALE      1PROJECTION   LATLON""".format(filedir, dem.width, dem.height,            dem.width - 1, dem.height - 1,            dem.extent.XMin + (cell * 0.5), dem.extent.YMax - (cell * 0.5),            cell, cell * -1)        rscfile = os.path.join(outfolder, outname + ".dem.rsc")        # io.open() used to ensure unix new lines for ROIPAC        with io.open(rscfile, 'w', newline='\n') as f:            f.write(fmt[1:])        f.close()        if tmp_agg:            arcpy.Delete_management(tmp_agg)        out_tif = os.path.join(outfolder, outname + "_tif.tif")        arcpy.management.CopyRaster(tmp_raster, out_tif)        arcpy.Delete_management(tmp_raster)        messages.addMessage("Created:\n{}\n{}\n{}".format(            out_dem, rscfile, out_tif))        returnclass ROIPACImport(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "ROIPAC Import"        self.description = "Import unwrapped ROIPAC interferogram phase image and convert to cm"        self.canRunInBackground = True    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName="Input Raster",            name="in_raster",            datatype="GPRasterLayer",            parameterType="Required",            direction="Input")                    param1 = arcpy.Parameter(            displayName="Output raster",            name="out_raster",            datatype="DERasterDataset",            parameterType="Required",            direction="Output")                    param2 = arcpy.Parameter(            displayName="Platform",            name="platform",            datatype="GPString",            parameterType="Optional",            direction="Input")        param2.filter.list = ["ALOS", "ENVISAT"]                param3 = arcpy.Parameter(            displayName="rscfile",            name="rscfile",            datatype="DEFile",            parameterType="Optional",            direction="Input")        param3.filter.list = ["rsc"]        return [param0, param1, param2, param3]    def isLicensed(self):        """Allow the tool to execute, only if the ArcGIS Spatial Analyst extension        is available."""        try:            if arcpy.CheckExtension("spatial") != "Available":                raise Exception        except Exception:            return False  # tool cannot be executed        return True  # tool can be executed    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        if parameters[0].value:            # If there is a Band_2 assume it is unwrapped phase in Band 2            # (this is how it comes from ROIPAC)            ras = arcpy.Describe(parameters[0].valueAsText).catalogPath            parameters[0].setWarningMessage(ras)            if arcpy.Exists(ras + "/Band_2"):                parameters[0].setWarningMessage("Assuming Band 2 is phase image in radians (ROIPAC convention)")            # set default output raster name            if not parameters[0].hasBeenValidated:                ras = arcpy.Describe(parameters[0].value).catalogPath                rasname = os.path.basename(ras)                oras = arcpy.ValidateTableName(os.path.splitext(rasname)[0])                try:                    if arcpy.env.workspace[-4:] != ".gdb":                        oras = oras + ".tif"                except:                    pass                parameters[1].value = os.path.join(arcpy.env.workspace, oras)                            if arcpy.Describe(ras).SpatialReference.name == "Unknown":                parameters[3].enabled = True            else:                parameters[3].enabled = False                parameters[3].value = None    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        if not parameters[2].value:            parameters[2].value = "ALOS"        return    def execute(self, parameters, messages):        """The source code of the tool."""        import os        import math        from arcpy import env        from arcpy.sa import Raster                def rscwarp(in_raster, out_raster, rscfile):            with open(rscfile) as rfile:                d = {}                for line in rfile:                    (key, val) = line.split()                    d[key] = val            xfirst, yfirst = [                float(d[k]) for k in ("X_FIRST", "Y_FIRST")]            (xmin, xmax, ymin, ymax) = [                float(d[k]) for k in ("XMIN", "XMAX", "YMIN", "YMAX")]            xstep, ystep  = [                float(d[k]) for k in ("X_STEP", "Y_STEP")]            xyin = "{} {};{} {};{} {}".format(                xmin, ymax, xmin, ymin, xmax, ymax)            xyout = "{} {};{} {};{} {}".format(                xfirst, yfirst, xfirst, yfirst + (ystep * ymax),                    xfirst + (xstep * xmax), yfirst)                                messages.addMessage("XMIN, XMAX, YMIN, YMAX: {}".format(                (xmin, xmax, ymin, ymax)))            messages.addMessage("Extent: {}".format(                (xfirst, yfirst + (ystep * ymax), xfirst + (xstep * xmax), yfirst)))                                arcpy.management.Warp(in_raster, xyin, xyout,                 out_raster, "POLYORDER1", "BILINEAR")            arcpy.management.DefineProjection(out_raster,                arcpy.SpatialReference(4326))                        input_raster = parameters[0].valueAsText        # If there is a Band_2 assume it is unwrapped phase in Band 2        # (this is how it comes from ROIPAC)        ras = arcpy.Describe(input_raster).catalogPath        b2 = os.path.join(ras, "Band_2")        if arcpy.Exists(b2):            ras = b2            messages.addMessage("Using {}".format(ras))        output_raster = parameters[1].valueAsText        platform = parameters[2].valueAsText        platform = str(platform).upper()        if platform == "ALOS":            lam = 23.62        else:            lam = 5.66        messages.addMessage("")        messages.addMessage("Wavelength for {}: {} cm".format(platform, lam))        messages.addMessage("Converting radians to cm: (-x / 2*pi) * ({} / 2.0)) ...".format(lam))        outras = ((-1 * arcpy.sa.Raster(ras)) / (2 * math.pi)) * (lam / 2.0)        # if rsc file is specified, georeference raster        rscfile = parameters[3].valueAsText        if rscfile:            messages.addMessage("Georeferencing using {}...".format(rscfile))            tmp = arcpy.CreateScratchName("x2", ".tif", "RasterDataset", arcpy.env.scratchFolder)            outras.save(tmp)            rscwarp(tmp, output_raster, rscfile)            arcpy.Delete_management(tmp)        else:            outras.save(output_raster)        returnclass DMtoBox(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Corners to Box"        self.description = "Convert four latitude longitude coordinates to a polygon"        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName="LatLong1",            name="latlong1",            datatype="GPString",            parameterType="Required",            direction="Input")        param1 = arcpy.Parameter(            displayName="LatLong2",            name="latlong2",            datatype="GPString",            parameterType="Required",            direction="Input")        param2 = arcpy.Parameter(            displayName="LatLong3",            name="latlong3",            datatype="GPString",            parameterType="Required",            direction="Input")        param3 = arcpy.Parameter(            displayName="LatLong4",            name="latlong4",            datatype="GPString",            parameterType="Required",            direction="Input")        param4 = arcpy.Parameter(            displayName="Output polygon",            name="out_polygon",            datatype="DEFeatureCLass",            parameterType="Required",            direction="Output")        return [param0, param1, param2, param3, param4]    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        for ip in range(4):            if parameters[ip].value:                try:                    test = [float(x) for x in parameters[ip].valueAsText.split()]                    if len(test) not in [2, 4]: raise Exception                except:                    parameters[ip].setErrorMessage("Invalid format")        return    def execute(self, parameters, messages):        """The source code of the tool."""        pts = [parameters[k].valueAsText for k in range(4)]              out_poly = parameters[4].valueAsText                pts = [[float(p) for p in p.split()] for p in pts]        # convert d m to deg if necessary        pts1 = []        for p in pts:            if len(p) == 4:                if p[0] < 0:                     p[1] = p[1] * -1                if p[2] < 0:                    p[3] = p[3] * -1                pp = [p[0] + p[1] / 60.0, p[2] + p[3] / 60.0]            else:                pp = p            pts1.append(pp)                # pts1 is in the form: [[40.0, -75.0], [40.25, -75.0], [40.35, -74.75], [40.08, -74.75]]                   if arcpy.GetInstallInfo()["ProductName"] == "Desktop":            outfolder = "in_memory"        else:            outfolder = "memory"        # create empty feature class and populate it with our points        SR = arcpy.SpatialReference(4326)  #GCS WGS84            ptfc = arcpy.CreateFeatureclass_management(            outfolder, "xxtmp", "POINT", spatial_reference=SR)        with arcpy.da.InsertCursor(ptfc, "Shape") as rows:           for xy in pts1:                p = arcpy.Point(xy[1],xy[0])  # lat, long is y,x                rows.insertRow([p])        # convert to polygon        arcpy.management.MinimumBoundingGeometry(ptfc, out_poly, "CONVEX_HULL", "ALL")           arcpy.management.Delete(ptfc)        returnclass RasterRanger(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Raster Ranger"        self.description = "Calculate parameters for display of unwrapped IfSAR"        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName="Input raster",            name="input_raster",            datatype="GPRasterLayer",            parameterType="Required",            direction="Input")        param1 = arcpy.Parameter(            displayName="Cycle length (cm)",            name="cycle_length",            datatype="GPDouble",            parameterType="Optional",            direction="Input")        param2 = arcpy.Parameter(            displayName="Number of cycles",            name="cycles",            datatype="GPLong",            parameterType="Optional",            direction="Input")        param3 = arcpy.Parameter(            displayName="Range min",            name="range_min",            datatype="GPDouble",            parameterType="Optional",            direction="Input")        param4 = arcpy.Parameter(            displayName="Range max",            name="range_max",            datatype="GPDouble",            parameterType="Optional",            direction="Input")        param5 = arcpy.Parameter(            displayName="Output layer",            name="output_layer",            datatype="GPRasterLayer",            parameterType="Derived",            direction="Output")        param2.filter.type = 'Range'        param2.filter.list = [1,20]        return [param0, param1, param2, param3, param4, param5]    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        # if raster selected, populate min and max the raster        # user can then override this        if parameters[0].value:            try:                rast = Raster(arcpy.Describe(                parameters[0].valueAsText).catalogPath)                if rast.minimum == None:                    try:                        arcpy.CalculateStatistics_management(rast)                        rast = Raster(arcpy.Describe(                            parameters[0].valueAsText).catalogPath)                    except:                        raise Exception("Could not calculate raster statistics")            except:                return        else:            for k in range(1,5):                parameters[k].value = None            return        # if user changes raster initialize values        if not parameters[0].hasBeenValidated:            parameters[1].value = rast.maximum - rast.minimum            parameters[2].value = 1            parameters[3].value = rast.minimum            parameters[4].value = rast.maximum            return        # # if range parameters outside range, set from raster        # rmin,rmax = parameters[3].value, parameters[4].value                # if float(rmin) < rast.minimum or float(rmin) > rast.maximum:             # parameters[3].value = rast.minimum        # if float(rmax) < rast.minimum or float(rmin) > rast.maximum:             # parameters[4].value = rast.maximum                     # in the Pro tool we can't handle modifying range so just set it        rmin, rmax = rast.minimum, rast.maximum        parameters[3].value, parameters[4].value = rmin, rmax        # calculate data range to display             rdelt = rmax - rmin                                    # if user clears length or changes number of cycles, calc length        if parameters[1].value == None or not parameters[2].hasBeenValidated:            parameters[1].value = rdelt / float(parameters[2].value)                    # if user clears # of cycles or changes length, calc # of cycles        if parameters[2].value == None or not parameters[1].hasBeenValidated:            parameters[2].value = int(rdelt / float(parameters[1].value))                     # if cycles is zero, or length is too long, re-initialize        if parameters[2].value < 1 or parameters[2].value > rdelt:            parameters[1].value = rdelt            parameters[2].value = 1                    # # set min and max        # rmin,rmax = rast.minimum, rast.maximum        # parameters[3].value = rmin        # parameters[4].value = rmax        # parameters[3].enabled = False # read only        # parameters[4].enabled = False        # rdelt = rmax - rmin        # # with min and max validated, we can set up length and cycles        # if not parameters[1].value and not parameters[2].value:            # # initialize to one cycle            # parameters[1].value = rdelt            # parameters[2].value = 1        # else:            # # if cycles or clen not set or not validated, calculate the other            # if not parameters[2].value or not parameters[1].hasBeenValidated:                # parameters[2].value = int(rdelt / float(parameters[1].value))            # elif not parameters[1].value or not parameters[2].hasBeenValidated:                # parameters[1].value = rdelt / float(parameters[2].value)        # # now we have values for everything. If too many cycles cut it back        # tmax = rmin + float(parameters[1].value) * float(parameters[2].value)        # if tmax - rast.maximum > 0.0001:            # parameters[2].value = rdelt / float(parameters[1].value)        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        # check for end of range less than max (last cycle not at max range)        try:            rast = Raster(arcpy.Describe(parameters[0].valueAsText).catalogPath)            rmin, rmax = float(parameters[3].value), float(parameters[4].value)            tmax = rmin + (parameters[1].value * parameters[2].value)            if (rmax - tmax) > 0.00001:                parameters[4].setWarningMessage(                    "Values above end of last cycle ({:.3f}) will not display.".format(tmax))        except:            pass        # # ArcGIS Pro check for Fringes.stylex        # if arcpy.GetInstallInfo()["ProductName"] == "ArcGISPro":            # try:                # p = arcpy.mp.ArcGISProject("CURRENT")                # p.listColorRamps("Fringex")[0]            # except:                # parameters[0].setErrorMessage("Fringes.stylex is not available to this ArcGIS Pro project.")        return    def execute(self, parameters, messages):        """The source code of the tool."""        rast = Raster(arcpy.Describe(parameters[0].valueAsText).catalogPath)        clen = float(parameters[1].value)        cycles = int(parameters[2].value)        rmin = float(parameters[3].value)        rmax = rmin + (cycles * clen)        msg = "Cycle length (cm): {:.3f}   Number of cycles: {}   min: {:.3f}   max: {:.3f}   range:{:.3f}".format(            clen, cycles, rmin, rmax, rmax - rmin)        messages.addMessage(msg)        msg = "Raster min: {:.3f}   max: {:.3f}   range: {:.3f}".format(rast.minimum, rast.maximum, rast.maximum - rast.minimum)        messages.addMessage(msg)        if rast.maximum - rmax > 0.01:            messages.addWarningMessage((                "Cycle range is {:.3f}, raster range is {:.3f}").format(rmax - rmin, rast.maximum - rast.minimum))        # Unlike ArcMap version, can't get this to work with custom        # ranges, just actual min max from raster.        #        # Enhancement request logged with Esri 3/2021:        #   Esri Case #02754886 - arcpy.mp workflow to replace arcpy.mapping.Layer.reclassify()        #        # create output layer and add to map        if cycles == 1:            ctext = "cycle"        else:            ctext = "cycles"        results = "{:.1f} cm ({} {}) {}".format(            clen, cycles, ctext, os.path.basename(rast.catalogPath))        outlyr = arcpy.MakeRasterLayer_management(rast.catalogPath, results)        fringe_shades = os.path.join(os.path.dirname(__file__),             "lyrx", "Fringe{}.lyrx".format(cycles))        outlyr = arcpy.ApplySymbologyFromLayer_management(outlyr, fringe_shades, None, "UPDATE")        parameters[5].value = outlyr        arcpy.SetParameterAsText(5, outlyr)        returnclass ZeroOff(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Raster Ranger Zero Off"        self.description = "Turn zero values off"        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName="Raster layer",            name="raster_layer",            datatype="GPLayer",            parameterType="Required",            direction="Input")        return [param0]    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""    def execute(self, parameters, messages):        # use CIM to set exclusion ranges        p = arcpy.mp.ArcGISProject("CURRENT")        m = p.activeMap        ly = m.listLayers(parameters[0].valueAsText)[0]        lyc = ly.getDefinition('V2')        lyc.colorizer.exclusionRanges = [-.0001, .0001]        ly.setDefinition(lyc)        returnclass SNAPImport(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "SNAP Import"        self.description = "Set cells below "        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName="Displacement raster (unwrapped, m)",            name="disp_raster",            datatype="GPRasterLayer",            parameterType="Required",            direction="Input")        param1 = arcpy.Parameter(            displayName="Output raster",            name="output_raster",            datatype="DERasterDataset",            parameterType="Required",            direction="Output")        param2 = arcpy.Parameter(            displayName="Scale factor (100 for m to cm)",            name="scale_factor",            datatype="GPDouble",            parameterType="Optional",            direction="Output")        param3 = arcpy.Parameter(            displayName="Coherence image",            name="coherence_raster",            datatype="GPRasterLayer",            parameterType="Optional",            direction="Input")        param4 = arcpy.Parameter(            displayName="Coherence threshhold",            name="coh_thresh",            datatype="GPDouble",            parameterType="Optional",            direction="Input")        return [param0, param1, param2, param3, param4]    def isLicensed(self):        """Set whether tool is licensed to execute."""        try:            if arcpy.CheckExtension("spatial") != "Available":                raise Exception        except Exception:            return False  # tool cannot be executed        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""                # set default output raster name        if not parameters[0].hasBeenValidated:            ras = arcpy.Describe(parameters[0].value).catalogPath            rasname = os.path.basename(ras)            oras = arcpy.ValidateTableName(os.path.splitext(rasname)[0])            parameters[1].value = os.path.join(arcpy.env.workspace, oras)                        # populate defaults threshhold only if we have a coherence raster        try:            scale_factor = float(parameters[2].value)        except:            scale_factor = 100.0        parameters[2].value = scale_factor        if parameters[3].value:            parameters[4].enabled = True            if not parameters[4].value or float(parameters[4].value) < 0.001:                parameters[4].value = 0.5        else:            parameters[4].value = None            parameters[4].enabled = False        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        if parameters[1].value:            pth = parameters[1].valueAsText.lower()            if pth.find(".gdb") > -1 and pth.find(".tif") > -1:                parameters[1].setErrorMessage("Cannot write .tif format to file geodatabase")    def execute(self, parameters, messages):        """The source code of the tool."""        from arcpy.sa import Float, Con, SetNull, IsNull, Expand, FocalStatistics, NbrCircle        messages.addMessage(parameters[0].value)        disp_raster = Raster(arcpy.Describe(parameters[0].value).catalogPath)        output_raster = str(parameters[1].value)        scale_factor = float(parameters[2].value)        if parameters[3].value:            coh = True            coherence_raster = Raster(arcpy.Describe(parameters[3].value).catalogPath)        else:            coh = False        try:            coh_thresh = float(parameters[4].value)        except:            coh_thresh = 0        # convert SNAP phase raster from m to cm        outras = Float(disp_raster) * scale_factor        if coh and coh_thresh > 0:            # set cells below coherence threshhold to NoData            outras1 = Con(coherence_raster > float(coh_thresh), outras)            outras = outras1        outras.save(output_raster)        return